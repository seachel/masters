The goal of this research is to increase the reasoning abilities of an existing system that is intended to help mechanize programming language metatheory. The system that this work contributes to is called Hybrid~\cite{FeltyMomigliano:JAR10}\index{Hybrid} and is part of the research program carried out by the Software Correctness and Safety Research Laboratory at the University of Ottawa under the supervision of Professor Amy Felty. Hybrid is implemented both in Coq~\cite{coq}\index{Coq} and Isabelle/HOL~\cite{NPW:2002}, interactive proof assistants used for applications such as formalizing mathematics, certifying compilers, and proving correctness of programs. Our application of Coq is proving metatheory of formal systems efficiently. The contributions to Hybrid described in this thesis are to the Coq implementation.

\section{Mechanized Reasoning}

Proof is essential in modern mathematics and in logic in particular. We trust and build on the work of others when we can see that they have presented a rigorous argument supporting their work. When writing proofs with many cases or details to manage, it is easy to make errors and these proofs are tedious to check. So we must trust the proof writer (and all proofs that their work builds on) or else spend an exorbitant amount of time checking proofs (and still possibly miss errors). Proof assistants such as Coq provide proof terms that can be independently checked. To trust all proof terms of theorems proven in Coq, one only needs to trust the underlying proof theory and the implementation of the system checking the proof.

Manually checking ``paper and pencil'' (non-formalized) proofs is not a scalable or practical technique for applications to software development in industry where financial concerns may be prioritized over software correctness and safety. The area of formal methods for software engineering is focused on (im)proving the correctness of software. Even if we develop techniques to allow software developers to prove correctness of software without needing expertise in the research area, we still need to be sure that the languages in which the programs are defined cause the expected behaviour. We need a mechanized solution to studying programming language metatheory.

Toward this goal, the \poplmark{}\index{POPLmark} challenge~\cite{Aydemir05TPHOLs} was introduced to merge the concerns of the proof theory and programming languages communities. It provides a set of challenge problems to explore how to mechanize programming language metatheory using a variety of systems and techniques and illustrates the importance of formalized reasoning in programming language research. In fact, it is standard for papers presented at programming language conferences to be accompanied by formal proofs of the metatheory, again for reasons related to confidence in the correctness of the work.

One approach to mechanize reasoning about programming languages involves higher-order abstract syntax. This technique is used by Hybrid, the system that the work in this thesis contributes to.

%Implementing Hybrid in an existing trusted general-purpose theorem prover makes it possible to easily make modular changes to the system.

\section{Higher-Order Abstract Syntax}
\label{sec:introhoas}

\emph{Higher-order abstract syntax}\index{higher-order abstract syntax} (HOAS)~\cite{PE:PLDI88}, also known as \lambda-tree syntax~\cite{MillerP99}\index{\lambda-tree syntax}, is a technique for representing formal systems, known as \emph{object logics} (OLs)\index{object logic}, that we wish to reason about. A variety of systems exist that implement a HOAS approach to reasoning about OLs such as programming languages and logics. An early example is the Twelf system~\cite{TwelfSP}. HOAS simplifies reasoning about OLs in these systems by allowing object-level name binding structures, also called \emph{binders}\index{binder}, to be encoded in the binding structures of the meta-language that the system is defined in.

As an example, we will illustrate a HOAS encoding of the untyped \lambda-calculus (the OL) in a type theory (the meta-level) so that we can reason about it formally. Function abstraction in \lambda-calculus is a \emph{binder} because the name of a variable is bound in the body of the abstraction. Let $\mathit{tm}$ be the meta-level type of terms of the OL encoding. Suppose that we have constants expressing the higher-order syntax of terms, including $\mathit{app}$ of type $\mathit{tm} \rightarrow \mathit{tm} \rightarrow \mathit{tm}$ and $\mathit{abs}$ of type $(\underline{\mathit{tm}} \rightarrow \mathit{tm}) \rightarrow \mathit{tm}$. Then $\mathit{abs}$ represents the function abstraction construct of the OL, an object-level binder, and it is encoded in a meta-level binder. For example, the \lambda-term $\lambda x . \lambda y . x \; y$ can be encoded as $\mathit{abs} (\lambda x \, . \, (\mathit{abs} (\lambda y \, . \, (\mathit{app} \; x \; y))))$. Note that $\mathit{tm}$ cannot be defined inductively because of the (underlined) negative occurrence of $\mathit{tm}$ in the type of $\mathit{abs}$.

When the metalanguage is an appropriate \lambda-calculus, we can encode object-level substitution and renaming as meta-level \beta-reduction and \alpha-conversion, respectively. This avoids the requirement of implementing infrastructure consisting of libraries of definitions and lemmas to deal with issues surrounding binders and variable naming when studying an OL.

\section{Hybrid}

Coq is an implementation of a typed \lambda-calculus called the calculus of constructions. Hybrid is implemented as a Coq library so the meta-language is a \lambda-calculus. A type $\mathit{expr}$ is defined for representing OL ``programs'' as meta-level terms. In Hybrid this is implemented so that terms of type $\mathit{expr}$ expand to a nameless representation of \lambda-terms called de Bruijn indices~\cite{debruijn}\index{de Bruijn indices}. Hybrid uses HOAS and object-level binders are encoded in a newly introduced abstraction binder. This binder has type $(\mathit{expr} \rightarrow \mathit{expr}) \rightarrow \mathit{expr}$. It can be used to directly express the syntax of OLs such as the untyped \lambda-calculus example in Section~\ref{sec:introhoas}.

An intermediate reasoning layer called a \emph{specification logic} (SL)\index{specification logic} is added to interface between the OL encoding and the layer implementing HOAS. Adding a SL extends the class of OLs that we can reason about efficiently using a system supporting HOAS. The relationship between these levels is the reason Hybrid is considered a \emph{two-level} logical framework\index{two-level logical framework}. This approach was introduced by McDowell and Miller in~\cite{McDowellMiller:TOCL01} with the $\mathit{FO\lambda^{\Delta \mathbb{N}}}$ logic. In such a system, the specification and (inductive) meta-reasoning are done within a single system but at different levels. In Hybrid the SL is defined as an inductive type in Coq, and OL judgments (including hypothetical and parametric judgments) are encoded in the SL.

\section{Specification Logic Metatheory}

There are many features of Hybrid that help work toward the goal of efficiently mechanizing programming language metatheory, but this thesis is focused on the SL layer. Here we makes two contributions: an extension to the reasoning power of Hybrid and new insight into proofs of properties of certain kinds of sequent calculi.

First, a new SL is implemented and structural properties of this logic are formalized and proven in the Coq proof assistant. The new SL presented here is a sequent calculus based on the logic of hereditary Harrop formulas as presented in~\cite{LProlog}. We prove that the standard structural rules of weakening, contraction, exchange and cut are admissible in this logic. In proving admissibility of these rules, we do not have to include them in the logic as axiomatic and we still get the benefits that they provide in reasoning about OLs. The structural rules can then be used in proofs of OL theorems. For example, if the OL is a typed functional programming language, then proving subject reduction for this OL (i.e. that evaluation of expressions preserves typing) requires the cut rule. See~\cite{FeltyMomigliano:JAR10} for a detailed explanation of this example and subject reduction proof. Implementing a new SL and proving the admissibility of structural rules is a concrete extension to an existing computing tool (namely Hybrid) since it improves the reasoning abilities of this system in a fully formalized way.

The second contribution is more theoretical and educational. We present a generalization of the specification logic and form of theorem statement to encapsulate the implemented SL and desired structural rules, respectively. We show how the implemented SL can be instantiated from this generalized SL, so the results presented for the generalized SL can be applied to, and provide guidance on, the proofs of SL metatheory. The structural proofs are by induction, sometimes requiring mutual inductions and nested inductions, so they can have many cases and details to manage. This presentation allows us to see the structural proofs in a more condensed but still comprehensive way. We are also able to gain a deeper understanding of these proofs; the generalized SL helped us to partition cases for the original SL into classes with the same proof structure and isolate the difficult cases. It is our hope that this presentation will give others insight into the kind of proofs we work through and that this general framework may find some use in other applications.

\section{Outline}

This thesis is broken up into two parts: background and contributions. To understand the research described here, it is necessary to first ensure that the reader understands the logical foundations of the ambient reasoning system for this work (namely Coq), the basics of Hybrid, and the development of the style of logic used for the new SL. In Chapter~\ref{ch:coq} we review the type theory implemented by Coq and introduce the reader to using it as a proof assistant. We present an overview of Hybrid in Chapter~\ref{ch:hybrid}. The final background chapter, Chapter~\ref{ch:hh}, is on the logic of higher-order hereditary Harrop formulas and will set the stage for the SL of this thesis. Next we move to the contributions of this research. As stated above, this is focused on a new intermediate reasoning logic for Hybrid. Chapter~\ref{ch:sl} presents this logic and its metatheory is studied in Chapter~\ref{ch:slind}. From here we abstract the specification logic of Chapter~\ref{ch:sl} with a generalized specification logic in Chapter~\ref{ch:gsl} and prove properties of this logic in a general way in Chapter~\ref{ch:gslind}. We conclude in Chapter~\ref{ch:concl} with a review of the results presented and look at related and future work.

The research presented in this thesis is published in~\cite{BF:LFMTP16}. The files of the Coq formalization are available at \url{www.eecs.uottawa.ca/~afelty/BattellThesis/}.